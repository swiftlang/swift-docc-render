<!--
  This source file is part of the Swift.org open source project

  Copyright (c) 2021-2023 Apple Inc. and the Swift project authors
  Licensed under Apache License v2.0 with Runtime Library Exception

  See https://swift.org/LICENSE.txt for license information
  See https://swift.org/CONTRIBUTORS.txt for Swift project authors
-->

<template>
  <pre
    ref="declarationGroup"
    class="source"
    :class="{ [multipleLinesClass]: displaysMultipleLines, 'has-multiple-lines': hasMultipleLines }"
  ><CodeBlock ref="code"><Token
    v-for="(token, i) in formattedTokens"
    :key="i"
    :class="extraClassesFor(token)"
    v-bind="propsFor(token)" /></CodeBlock></pre>
</template>

<script>
import { indentDeclaration } from 'docc-render/utils/indentation';
import { displaysMultipleLines } from 'docc-render/utils/multipleLines';
import { multipleLinesClass } from 'docc-render/constants/multipleLines';
import { getSetting } from 'docc-render/utils/theme-settings';
import Language from 'docc-render/constants/Language';
import CodeBlock from 'docc-render/components/CodeBlock.vue';
import DeclarationToken from './DeclarationToken.vue';

const { TokenKind } = DeclarationToken.constants;

const DEFAULT_INDENTATION_WIDTH = 4;

const HighlightKind = {
  added: 'added',
  changed: 'changed',
  removed: 'removed',
};

export default {
  name: 'DeclarationSource',
  data() {
    return {
      displaysMultipleLines: false,
      multipleLinesClass,
    };
  },
  components: { Token: DeclarationToken, CodeBlock },
  constants: { HighlightKind },
  props: {
    tokens: {
      type: Array,
      required: true,
    },
    language: {
      type: String,
      required: false,
    },
  },
  computed: {
    indentationWidth: () => getSetting([
      'theme',
      'code',
      'indentationWidth',
    ], DEFAULT_INDENTATION_WIDTH),
    formattedTokens: ({
      language,
      formattedSwiftTokens,
      tokens,
    }) => (language === Language.swift.key.api ? formattedSwiftTokens : tokens),
    // Return a formatted version of the tokens array, with additional
    // indentation whitespace to break parameters onto individual lines for
    // improved readability and scanning of Swift functions/initializers.
    //
    // This is implemented in a single pass loop where text tokens are updated
    // at certain key points to insert spaces and newlines so that each
    // parameter of a multi-parameter function gets its own line.
    //
    // Ideally this should be implemented with a tool like SwiftFormat in the
    // future with the raw text before it gets tokenized for syntax
    // highlightingâ€”however, this post-tokenization JavaScript logic should be
    // an improvement until that kind of work can be integrated.
    //
    // @param {Array} tokens The original syntax tokens.
    //   See `DeclarationToken.props`
    // @return {Array} A formatted version of the original tokens.
    //   See `DeclarationToken.props`
    formattedSwiftTokens: ({ indentationWidth, tokens }) => {
      const indent = ' '.repeat(indentationWidth);
      let indentedParams = false;
      const newTokens = [];
      let i = 0;
      let openParenTokenIndex = null;
      let openParenCharIndex = null;
      let closeParenTokenIndex = null;
      let closeParenCharIndex = null;
      let numUnclosedParens = 0;
      let firstKeywordTokenIndex = null;

      // loop through every declaration token
      while (i < tokens.length) {
        // keep track of the current token and the next one (if any)
        const token = tokens[i];
        const newToken = { ...token };
        const prevToken = tokens[i - 1];
        const nextToken = tokens[i + 1];

        // keep track of the index of the first keyword token
        if (!firstKeywordTokenIndex && token.kind === TokenKind.keyword) {
          firstKeywordTokenIndex = i;
        }

        // loop through the token text to look for "(" and ")" characters after
        // we've already encountered the first keyword
        if (firstKeywordTokenIndex !== null) {
          const tokenLength = (token.text || '').length;
          // eslint-disable-next-line no-plusplus
          for (let k = 0; k < tokenLength; k++) {
            if (token.text.charAt(k) === '(') {
              numUnclosedParens += 1;
              // keep track of the token/character position of the first "("
              if (openParenCharIndex == null) {
                openParenCharIndex = k;
                openParenTokenIndex = i;
              }
            }

            if (token.text.charAt(k) === ')') {
              numUnclosedParens -= 1;
              // if this ")" balances out the number of "(" characters that have
              // been seen, this is the one that pairs up with the first one
              if (
                openParenTokenIndex !== null
                && closeParenTokenIndex == null
                && numUnclosedParens === 0
              ) {
                closeParenCharIndex = k;
                closeParenTokenIndex = i;
                break;
              }
            }
          }
        }

        // Find the text following the last attribute preceding the start of a
        // declaration by determining if this is the text token in between an
        // attribute and a keyword outside of any parameter clause. A newline
        // will be added to break these attributes onto their own single line.
        if (token.kind === TokenKind.text && numUnclosedParens === 0
          && prevToken && prevToken.kind === TokenKind.attribute
          && nextToken && nextToken.kind === TokenKind.keyword) {
          newToken.text = `${token.text.trimEnd()}\n`;
        }

        // if we find some text ending with ", " and the next token is the start
        // of a new param, update this token text to replace the space with a
        // newline followed by 4 spaces
        const isStartOfParam = ({ kind }) => (
          kind === TokenKind.attribute || kind === TokenKind.externalParam
        );
        if (token.text && token.text.endsWith(', ') && nextToken && isStartOfParam(nextToken)) {
          newToken.text = `${token.text.trimEnd()}\n${indent}`;
          indentedParams = true;
        }

        newTokens.push(newToken);
        i += 1;
      }

      // if we indented some params, we want to find the opening "(" symbol
      // and add a newline and 4 spaces to the end of it, breaking the first
      // param onto its own line
      if (indentedParams && openParenTokenIndex !== null) {
        const originalText = newTokens[openParenTokenIndex].text;
        newTokens[openParenTokenIndex].text = `${originalText}\n${indent}`;
      }

      // if we indented some params, we want to find the closing ")" symbol
      // to prepend a newline to it so that the return clause is on its own
      // line and not included with the last param
      if (indentedParams && closeParenTokenIndex !== null) {
        const originalText = newTokens[closeParenTokenIndex].text;
        const begin = originalText.slice(0, closeParenCharIndex);
        const end = originalText.slice(closeParenCharIndex);
        const newText = `${begin}\n${end}`;
        newTokens[closeParenTokenIndex].text = newText;
      }

      return newTokens;
    },
    hasMultipleLines({ formattedTokens }) {
      return formattedTokens.reduce((lineCount, tokens, idx) => {
        let REGEXP = /\n/g;
        if (idx === formattedTokens.length - 1) REGEXP = /\n(?!$)/g;
        if (!tokens.text) return lineCount; // handles TokenKind add & changed
        return lineCount + (tokens.text.match(REGEXP) || []).length;
      }, 1) >= 2;
    },
  },
  methods: {
    propsFor(token) {
      return {
        kind: token.kind,
        identifier: token.identifier,
        text: token.text,
        tokens: token.tokens,
      };
    },
    handleWindowResize() {
      this.displaysMultipleLines = displaysMultipleLines(this.$refs.declarationGroup);
    },
    extraClassesFor(token) {
      return {
        highlighted: token.highlight === HighlightKind.changed,
      };
    },
  },
  async mounted() {
    window.addEventListener('resize', this.handleWindowResize);
    if (this.language === Language.objectiveC.key.api) {
      await this.$nextTick();
      indentDeclaration(this.$refs.code.$el, this.language);
    }
    this.handleWindowResize();
  },
  beforeDestroy() {
    window.removeEventListener('resize', this.handleWindowResize);
  },
};
</script>

<style scoped lang="scss">
@import 'docc-render/styles/_core.scss';

$indent-spacing: em(32px);
$horizontal-padding: em($code-source-spacing + rem(5px));

$docs-declaration-source-border-width: 1px !default;

.source {
  background: var(--background, var(--color-code-background));
  border-color: var(--color-grid);
  color: var(--text, var(--color-code-plain));
  border-radius: $large-border-radius;
  border-style: solid;
  border-width: $docs-declaration-source-border-width;
  padding: var(--code-block-style-elements-padding);
  speak: literal-punctuation;
  line-height: 25px;
  // we need to establish a new stacking context to resolve a Safari bug where
  // the scrollbar is not clipped by this element depending on its border-radius
  @include new-stacking-context;

  &.displays-multiple-lines {
    border-radius: $border-radius;
  }

  > code {
    @include font-styles(documentation-code-listing);
    display: block;
  }
}
</style>
